- 스프링 삼각형
:  POJO라는 것을 IoC/DI, AOP, PSA를 통해서 달성할 수 있다

============================================================================================
1. POJO(Plain Old Java Object)
-------------------------------------------------------------------------------------------------------------------------------------------------
'PO’는 Java로 생성하는 순수한 객체

POJO 프로그래밍이란 POJO를 이용해서 프로그래밍 코드를 작성하는 것
단순히 순수 자바 객체만을 사용하는 것만이 아니라 두 가지의 기본적인 규칙을 지켜야 한다. 

1. Java나 Java의 스펙(사양)에 정의된 것 이외에는 다른 기술이나 규약에 얽매이지 않아야 한다
2. 특정 환경에 종속적이지 않아야 한다.

POJO 프로그래밍이 필요한 이유
1. 특정 환경이나 기술에 종속적이지 않다 -> 재사용 가능, 확장 가능한 유연한 코드 작성 가능
2. 저수준 레벨의 기술과 환경에 종속적인 코드를 애플리케이션 코드에서 제거  -> 코드 간결, 디버깅 용이, 테스트 단순
3. 객체지향적인 설계를 제한없이 적용 가능 

Spring은 POJO 프로그래밍을 지향하는 Framework 
: Spring이 제공하는 기술 3가지 :  IoC/DI, AOP, PSA

- 객체 지향 설계 원칙 (SOLID)
https://itvillage.tistory.com/entry/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-%EC%9B%90%EC%B9%99-SOLID-%EC%9B%90%EC%B9%99


============================================================================================
2. IoC(Inversioin of Control)/DI(Dependency Injection)
-------------------------------------------------------------------------------------------------------------------------------------------------
 Framework은 애플리케이션 흐름의 주도권이 Framework에 있다
 ★IoC:  애플리케이션 흐름의 주도권이 뒤바뀐 것

일반적인 애플리케이션의 제어 흐름 : 개발자가 작성한 코드를 순차적으로 실행 

애플리케이션이 시작되는 지점을 엔트리 포인트(Entry point)라고 부른다. 
main( ) 메서드가 종료되면  애플리케이션이 종료되는 Java 콘솔 애플리케이션과 달리 
웹 상에서 구동되는 Java 웹 애플리케이션은  클라이언트가 외부에서 접속해서 사용하는 서비스이기 때문에 main이 종료되지 않아야 한다. 
 서블릿 컨테이너에는 서블릿 사양(Specification)에 맞게 작성된 서블릿 클래스만 존재하고, 별도의 main() 메서드가 존재하지 않는다. 


서블릿 컨테이너는 클라이언트의 요청이 들어올 때마다 서블릿 컨테이너 내의 컨테이너 로직(service() 메서드)이 서블릿을 직접 실행시켜 주기 때문에 main() 메서드가 필요 없다. 
서블릿 컨테이너가 서블릿을 제어하고 있기 때문에 애플리케이션의 주도권은 서블릿 컨테이너에 있다. 
-> 서블릿과 웹 애플리케이션 간에 IoC(제어의 역전)의 개념이 적용

★ DI를 통해 IoC를 적용한다. 
DI(Dependency Injection)란? 
:  IoC 개념을 조금 구체화 시킨 것, 의존성 주입 

객체지향 프로그래밍에서의 의존성 : 객체 간의 의존성
특정 클래스가 다른 클래스의 기능을 사용->  해당 클래스는 다른 클래스에 의존한다

+) 클래스 다이이어그램 도구: https://online.visual-paradigm.com/diagrams/features/

- ★ 의존성 주입
생성자를 통해서 어떤 클래스의 객체를 전달 받는 것을 ‘의존성 주입’
생성자의 파라미터로 객체를 전달하는 것 = 외부에서 객체를 주입

+) 클라이언트 측면에서 서버의 엔드포인트(Endpoint): 클라이언트가 서버의 자원(리소스, Resource)을 이용하기 위한 끝 지점

- 의존성 주입을 사용할 때, 항상 염두에 두어야 하는 부분
:  현재의 클래스 내부에서 외부 클래스의 객체를 생성하기 위한 new 키워드를 쓸지 말지 여부를 결정
일반적으로 Java에서 new 키워드를 사용해서 객체를 생성하는데, 
Reflection이라는 기법을 이용해서 Runtime시에 객체를 동적으로 생성할 수 있는 방법이 있다

★ 애플리케이션 코드 내부에서 직접적으로 new 키워드를 사용할 경우 객체지향 설계의 관점에서 중요한 문제 발생 가능

+) 스텁(Stub) : 메서드가 호출되면 미리 준비된 데이터로 응답하는 것,  고정된 데이터이기 때문에 몇 번을 호출해도 동일한 데이터를 리턴
+) 멱등성(idempotent)을 가진다 : 몇번을 호출해도 동일한 데이터를 리턴하는 것

new 키워드를 사용해서 객체를 생성하게 되면 참조 할 클래스가 바뀌게 될 경우, 이 클래스를 사용하는 모든 클래스들을 수정해야 한다. 
★ new 키워드를 사용해서 의존 객체를 생성->  클래스들 간에 강하게 결합(Tight Coupling)되어 있다
존성 주입을 하더라도 의존성 주입의 혜택을 보기 위해서는 클래스들 간의 강한 결합은 피하는 것이 좋다 -> 느슨한 결합(Loose Coupling)

- 느슨한 의존성 주입
1.  인터페이스(Interface)를 사용하는 것 
★ 어떤 클래스가 인터페이스 같이 일반화된 구성 요소에 의존 ->  클래스들 간에 느슨하게 결합(Loose Coupling)되어 있다

2. 업캐스팅(Upcasting):  인터페이스 타입의 변수에 그 인터페이스의 구현 객체를 할당
업캐스팅을 통한 의존성 주입 -> 느슨한 결합 관계 유지 가능 

3. new 키워드 제거 
★ Spring에서 지원하는 API 코드와 Config 클래스를 통해  new 키워드로 객체를 생성하던 것을 Spring이 대신 해준다. 
 Config 클래스의 역할 : Config 클래스에 정의해둔 객체를 Spring의 도움을 받아서 다른 클래스에게 제공

============================================================================================
3. AOP(Aspect Oriented Programming)
-------------------------------------------------------------------------------------------------------------------------------------------------
관심 지향 프로그래밍 
애플리케이션에 필요한 기능 중에서 공통적으로 적용되는 공통 기능에 대한 관심 -> 공통 관심 사항(Cross-cutting concern)
애플리케이션의 주목적을 달성하기 위한 핵심 로직에 대한 관심사-> 핵심 관심 사항(Core concern)
공통 관심 사항을 부가적인 관심 사항이라고도 표현

ex)
주문, 메뉴 등록 -> 핵심 관심 사항
로그, 보안, 트랜잭션 -> 공통 관심 사항

애플리케이션의 핵심 업무 로직에서 로깅이나 보안, 트랜잭션 같은 공통 기능 로직들을 분리하는 것이 AOP

- AOP가 필요한 이유( 애플리케이션의 핵심 로직에서 공통 기능을 분리하는 이유 )
코드의 간결성 유지
객체 지향 설계 원칙에 맞는 코드 구현
코드의 재사용

애플리케이션에 전반에 걸쳐 적용되는 공통 기능(트랜잭션, 로깅, 보안, 트레이싱, 모니터링) 등을 
비즈니스 로직에서 깔끔하게 분리하여 재사용 가능한 모듈로 사용 가능 

eX) 트랜잭션 기능에 대해 AOP 미적용
트랜잭션(Transaction)이란 ‘데이터를 처리하는 하나의 작업 단위’를 의미
A 데이터와 B 데이터를 두 번에 걸쳐 각각 insert 하는 작업을 하나의 트랜잭션으로 묶는다
A 데이터와 B 데이터는 모두 데이터베이스에 저장되던가 아니면 둘 중에 하나라도 오류로 인해 저장되지 않는다면
 A, B 데이터는 모두 데이터베이스에 반영되지 않아야 한다.(All or Nothing)

이를 위해 트랜잭션의 커밋(commit) 또는 롤백(rollback)이라는 기능이 존재
커밋 : 모든 작업이 성공적으로 수행되었을 경우 수행한 작업을 데이터베이스에 반영
롤백 : 작업이 하나라도 실패한다면 이전에 성공한 작업들을 작업 수행 이전 상태로 되돌리는 것

트랜잭션 처리를 하는 코드들이 애플리케이션의 다른 기능에도 중복되어 나타날 수 있다.

-> 중복된 코드를 공통화해서 재사용 가능하도록 AOP를 사용
-> @Transactional 애노테이션 -> Spring 내부에서 이 애노테이션 정보를 활용해서 AOP 기능을 통해 트랜잭션을 적용

============================================================================================
4. PSA(Portable Service Abstraction)
-------------------------------------------------------------------------------------------------------------------------------------------------
객체지향 프로그래밍에서의 추상화(Abstraction) : 어떤 클래스의 본질적인 특성만을 추출해서 일반화 하는것
Java에서 코드로 추상화를 표현할 수 있는 대표적인 방법 :  추상 클래스와 인터페이스

-  일관된 서비스 추상화(PSA)의 기본 개념
ex) 업캐스팅 
 클라이언트가 추상화 된 상위 클래스를 일관되게 바라보며 하위 클래스의 기능을 사용하는 것
+) 코드 레벨에서 어떤 클래스의 기능을 사용하는 측 역시 클라이언트라고 부른다

- 서비스 추상화 :  추상화의 개념을 애플리케이션에서 사용하는 서비스에 적용하는 기법

ex)  Java 콘솔 애플리케이션에서 클라이언트가 데이터베이스에 연결하기 위해 JdbcConnector를 사용
     JdbcConnector가 애플리케이션에서 이용하는 하나의 서비스가 되는 것

client는  JdbcConnector 인터페이스의 구현체에 직접적으로 연결해서 Connection을 얻는 것이 아니라
 JdbcConnector 인터페이스를 통해 간접적으로 연결되어(느슨한 결합) Connection 객체를 얻는다. 

-> 일관된 방식으로 해당 서비스의 기능을 사용할 수 있다. 

- 일관된 서비스 추상화(PSA) 
: 애플리케이션에서 특정 서비스를 이용할 때, 서비스의 기능을 접근하는 방식 자체를 일관되게 유지하면서 기술 자체를 유연하게 사용할 수 있도록 하는 것

- PSA가 필요한 이유
어떤 서비스를 이용하기 위한 접근 방식을 일관된 방식으로 유지함으로써 
애플리케이션에서 사용하는 기술이 변경되더라도 최소한의 변경만으로 변경된 요구 사항을 반영
( 요구 사항 변경에 유연하게 대처 가능 )


============================================================================================
