===============================================================
1. Deque( Deque는 Double Ended Queue)
----------------------------------------------------------------------------------------------
cf) Stack 
   : LIFO, 한 방향으로 데이터가 추가되고 삭제      
    Queue
  : FIFO, 입력방향, 출력방향
----------------------------------------------------------------------------------------------  
- 양방향 대기열 
----------------------------------------------------------------------------------------------
- 양방향으로 열려 있는 구조 
----------------------------------------------------------------------------------------------
- Stack과 Queue를 모두 사용할 수 있다. 
: 추가 / 삭제 양쪽에서 제어 가능 
1) 추가 제한 ( 입력 한 방향, 출력 두 방향) 

    입력 ->
<- 출력    출력-> 
: 왼쪽 출력 형태 = Stack, 오른쪽 출력 형태 = Queue

2) 삭제 제한 

입력 -> <- 입력
<- 출력 
: 왼쪽 입력 형태 = Stack, 오른쪽 입력 형태 = Queue
----------------------------------------------------------------------------------------------
- 양방향 끝에서 데이터 추가/삭제 용이 
: Deque도 양쪽의 추가/삭제할 데이터의 인덱스 정보를 가지고 있어
양쪽 끝 데이터에 접근/추가/삭제가 용이하다. 
하지만 양방향 끝이 아닌 중간에 존재하는 임의의 데이터만 접근/추가/삭제 불가
deque는 양쪽 끝의 인덱스만 가진다. 

===============================================================

2. Linked List ( 연결 리스트)
----------------------------------------------------------------------------------------------
선형으로 그룹화된 데이터의 집합
데이터와 다음 데이터의 주소를 포함하고 있는 하나의 노드가 선형으로 연결된 자료구조
----------------------------------------------------------------------------------------------
!) 배열과의 비교

배열은 연속된 공간 안에 메모리를 차지, 인덱스로 각각의 요소에 접근
연속된 주솟값 안에 데이터를 넣으므로 위치를 바꾸려면 데이터가 이동해야 한다.

Linked List 자료구조는 연속된 공간이 아닌 흩어진 공간에 노드 간의 연결로 이루어짐
하나의 노드에는 데이터와 다음 노드의 주소가 담겨 있다.
연속된 메모리 주소가 아니기 때문에 주솟값을 가지고 있어야 다음 노드로 접근 가능 
마지막 노드는 다음이 없으므로 새로운 요소가 추가되기 전까지는 null
----------------------------------------------------------------------------------------------
노드의 추가와 삭제가 빠르고 쉽다. 
메모리 순서가 정해져 값 추가/삭제 시 메모리에 재할당해야 하는 배열과 다르게 
// 시간 복잡도 증가 : O(n)
Linked List는 순서가 지정되지 않기 때문에 데이터를 담은 노드를 어디에나 쉽게 추가하거나 삭제할 수 있다.
(추가 시 다음 노드를 가리키는 메모리 주소만 변경)
(삭제 시 추가된 노드가 null을 가리키도록, 이전 요소가 삭제할 다음 요소를 가리키도록 변경)
// 빠른 시간 복잡도 : O(1)
----------------------------------------------------------------------------------------------
노드이 값을 찾으려면 최대 전체를 순회해야 한다. 
Linked List의 노드는 메모리에 흩어져 있어 특정 노드로 쉽게 접근할 수 없다. 

배열은 메모리에 연속적으로 할당되어 주소 접근이 쉬움 // O(1)

Linked List의 첫 번째 노드 : head node
순회 전까지는 head node의 정보만 알 수 있다. 
원하는 값이 있는 노드에 접근하기 위해서는 다음 노드로 이동해야 한다. 
head node의 정보 : 값, 리스트의 사이즈, 다음 노드의 주소 
마지막 요소에 접근하려면 최악의 경우 O(n)의 시간 복잡도 가진다. 
----------------------------------------------------------------------------------------------
삽입과 삭제가 중요한 곳에 활용 
동적 기억장소 관리 : 필요한 만큼의 메모리를 할당하는 데 사용
Garbage Collection : 참조자료형의 데이터 타입을 관리하는 알고리즘 중 하나 
Hash Table의 충돌 시 해결법 중 chaning에 활용 

----------------------------------------------------------------------------------------------
===============================================================

3. Hash Table
----------------------------------------------------------------------------------------------
해시함수(hash function)를 사용하여 변환한 해시(hash)를 색인(index)으로 삼아 키(key)와 데이터(value)를 저장하는 자료구조
Hash Table의 구조 : 키(key)와 해시함수(hash function), 해시(hash), 데이터(value)

키(Key)
 : 고유한 값, 해시함수의 입력값, 다양한 길이의 값이 들어올 수 있다. 
해시 함수( hash Function)
: 키를 해시로 바꿔주는 역할, 다양한 길이의 키를 일정한 길이의 해시로 변경해 저장소를 효율적으로 운영
 +) 서로 다른 키가 같은 해시가 되는 경우 : 해시 충돌
해시 (Hash)
: 해시함수의 결과물, 저장소에서 데이터와 매칭되어 저장되며 변환된 값을 배열의 인덱스처럼 사용
데이터 ( Value)
: 저장소에 최종적으로 저장되는 값으로, 인덱스와 매칭되어 저장된다. 
----------------------------------------------------------------------------------------------
Hash Table의 저장/삭제/검색은 모두 평균적으로 O(1)의 시간복잡도를 가진다 -> 빠르다
해시 충돌 발생가능성과 데이터 저장 전 저장곤간을 미리 만들기 때문에 공간 효율서이 떨어짐
해시 함수의 의존도가 높다. 
-> 해시함수가 복잡해지면 해시를 만드는데 시간이 많이 소요된다. 

저장/ 삭제 / 검색
만들어진 해시와 일치하는 인덱스를 찾아 저장 /삭제 / 검색
해시함수 -> 해시 의 과정은 고려하지 않지만 
해싱 충돌이 발생하면 저장소의 모든 인덱스나 데이터를 찾아야 하기 때문에 시간복잡도는 O(n)이 된다. 
----------------------------------------------------------------------------------------------
해시 알고리즘 
 
Division Method 
: Number 타입의 키를 저장소의 크기로 나누고 나머지를 인덱스로 사용
저장소의 크기를 소수(Prime Number)로 정하고 2의 제곱과 먼 값을 사용하는 것이 효과적

Digit Folding 
: 키의 문자열을 ASCII 코드로 바꾸고 그 값을 합해 저장소에서 인덱스로 사용
인덱스가 저장소의 크기를 넘으면 Division Method 적용 

Multiplication Method 
: 숫자로 된 키 값(K)과 0과 1사이의 실수 A, 2의 제곱인 m을 사용
index = ( KA mod 1) m 

Universal Hashing 
: 다수의 해시함수를 만들어 특정 장소에 넣고, 무작위로 해시함수를 선택해 해시값을 만든다.
----------------------------------------------------------------------------------------------
해시 충돌 해결법

1. 개방 연결법(Open Addressing)
: 해시 충돌이 발생 시 다른 인덱스에 해당 자료를 삽입하는 방식 

1-1. Linear Probing : 중복된 인덱스로부터 고정된 숫자만큼 이동해 비어있는 저장소를 찾아 데이터를 저장
1-2. Quadratic Probing : 중복된 인덱스로부터 이동할 숫자를 제곱으로 사용하는 방식
                              충돌 시 1(1^2) 이동, 4(2^2), 9(3^2), 16(4^2)만큼 이동해 빈 공간 탐색 
1-3. Double Hashing Probing : 하나의 해시함수에서 충돌 방생 시 미리 지정해둔 다른 해시함수를 이용해 새로운 주소를 받아 사용
                                       다른 방법들보다 많은 연산 필요 
 
2. 분리 연결법 ( Seperate Chaining)
: 동일한 인덱스에 대해 연결리스트(Linked List), 트리 (Red-Black Tree) 등의 자료구조를 활용해 데이터의 주소를 저장하는 방법
 동일한 버킷의 데이터에 자료구조를 활용해 충돌이 일어난 데이터를 저장 
 구현이 간단, 데이터 쉽게 삭제 가능
 중복 저장 데이터가 많아지면 동일 버킷에 연결되는 데이터가 많아져 검색의 효율성이 감소 

3. 저장소 확장( Resize)        
자바의 HashMap 자료구조는 매치된 key-value 데이터 개수가 일정 수 이상이 되면 저장소의 크기를 두 배로 늘린다.
-> 해시 충돌로 인한 성능 감소 어느정도 해결 가능 

----------------------------------------------------------------------------------------------
Hash Table 사용 
: 주소록, 블록체인, 자바스크립트 실행 엔진(크롬), Domain -> DNS 변환
----------------------------------------------------------------------------------------------
===============================================================

4. Heap Tree
----------------------------------------------------------------------------------------------
트리 구조로 구현된 자료구조
우선순위에 따라 빠르게 자료 검색 가능 
----------------------------------------------------------------------------------------------
느슨한 정렬 구조로 구현
: 부모 노드의 값은 자식 노드의 값보다 항상 크거나 항상 작게 정렬되어 있다.
  자식 노드 간에는 값의 크기에 따라 좌우 위치가 정렬되지 않기 때문에 느슨한 정렬 구조라고 표현 
----------------------------------------------------------------------------------------------
특징
1. 완전 이진 트리 :삽입/삭제 시 성능 향상,  단순 최대/최솟값 탐색을 찾을 때는 불필요
2. 중복된 값 저장 가능 
3. 최대 힙/ 최소 힙 
최대 힙 : 루트 노드( 가장 큰 값 위치), 자식 노드로 내려갈수록 작은 값이 위치
최소 힙: 루트 노드(가장 작은 값 위치), 자식 노드로 내려갈수록 큰 값이 위치 
----------------------------------------------------------------------------------------------
데이터 처리

1. 데이터 검색(최대값 / 최소값) 
최대 힙일 경우: 최대값 찾는 시간 복잡도 O(1)
최소 힙일 경우: 최소값 찾는 시간 복잡도 O(1)

2. 데이터 삽입 
- 가장 마지막 노드에 새로운 값 저장
- 삽입된 노드의 값과 부모 노드의 값을 비교
- 최대 힙일 경우, 부모의 값이 더 크다면 부모의 값과 위치를 서로 변경
- 반복 

3. 데이터 삭제 
- 루트 노드의 값 삭제
- 루트 자리에 마지막 노드의 값 삽입
- 루트 자리에 삽입된 값과 자식 노드들과의 값과 비교
- 최대 힙일 경우, 부모보다 더 큰 자식이 있다면 해당 자식의 값과 서로 교환 
  ( 두 자식의 값이 모두 부모보다 작으면, 두 값 중 더 큰 값과 위치 변경)
- 더 이상 큰값이 없을 때까지 반복 
----------------------------------------------------------------------------------------------
Heap tree -> 배열

heap tree는 완전 이진 트리로 구성되어 배열로 표현 가능 
완전 이진 트리의 특성 : 중간에 빈 값이 없다. -> 루트 노드로부터 높이 순서대로 배열에 정렬 가능 
일반적으로 배열의 첫 번째 인덱스부터 사용( 구현과 노드의 위치 탐색 편하게 )
높이 순서대로 배열에 값 저장 ( 좌측 노드 -> 우측 노드) // 동일 레벨 먼저 구현하고 하위 레벨로 
배열의 크기에 따라 heap tree의 depth와 부모와 자식 노드의 위치 쉽게 검색 가능 
depth : 배열의 길이가 1, 3, 7, 15 순서로 2의 배수를 더한만큼 늘어난다. 
현재 노드의 왼쪽 자식 노드의 인덱스 : 현재 노드의 인덱스 * 2
현재 노드의 오른쪽 자식 노드의 인덱스 : (현재 노드의 인덱스 * 2) + 1
부모의 인덱스 : 자식 노드의 인덱스 / 2 //내림 처리 
----------------------------------------------------------------------------------------------
heap tree는 우선순위 큐와 힙 정렬에 주로 사용 
----------------------------------------------------------------------------------------------
===============================================================