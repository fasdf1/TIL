시간 복잡도 
: 입력값의 변화에 따라 연산 실행 시 
  연산 횟수에 비해 시간이 얼마나 걸리는지에 대한 표현
  주로 빅-오 표기법을 사용해 나타낸다. 
--------------------------------------------------------------------------------------------------------------------------

시간 복잡도를 표기하는 방법 : Big- O, Big-Ω(빅-오메가), Big-θ(빅-세타)
: 각각 최악, 최선 , 중간(평균)의 경우를 표현 

--------------------------------------------------------------------------------------------------------------------------
Big-O 표기법
: 프로그램 실행 과정에서 최악의 경우(시간)를 고려

O(1) : contstant complexity
입력값이 증가하더라도 시간이 증가하지 않는다. 

O(n) : linear complexity 
입력값이 증가하면 같은 비율로 시간 또한 증가한다. 
입력값이 커질수록 계수의 의미가 없어지므로 시간 또한 같은 비율로 증가한다면, 
2배, 3배, 4배... 100배 증가하더라도 O(n)으로 표기 

ex) for문을 통해 배열에서 원하는 인덱스의 값을 찾기 (배열의 길이만큼 반복)

O(log n) :  logarithmic complexity
O(1) 다음으로 빠른 시간 복잡도  //n이 커질수록 빨라진다
ex) BST (Binary Search Tree) 
: 원하는 값을 탐색할 때 노드 이동 시마다 경우의 수가 절반으로 줄어든다. 

O(n2) : quadratic complexity
입력값 증가 -> 시간이 n^2의 비율로 증가 
2n,5n 모두 O(n)으로 표기하는 것과 같이 n3,n5도 O(n2)로 표현 
(n이 커질수록 지수의 영향력 작아짐)

ex) 이중 for문의 내부 for문 작업 

O(2n) :  exponential complexity

가장 느린 시간 복잡도
ex) 피보나치 수열 재귀함수 이용해 구현 
--------------------------------------------------------------------------------------------------------------------------
코드 작성 시 입력 데이터가 클 때는 O(n)이나 O(log n)의 시간 복잡도를 만족할 수 있도록 구현하는 것이 바람직하다.
 