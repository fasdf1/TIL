------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------
자바 이전에 많이 사용되던 C++은 운영체제로부터 독립적이지 못한 문제가 있었다.
( 프로그래밍 언어가 운영체제에 종속적 = 운영 체제 별 프로그램을 만들어줘야 했음)

자바는 소스 코드를 한 번 작성해두면 어떤 운영체제에서라도 코드 수정 없이 프로그랭 실행 가능
이러한 독립성은 JVM을 통해 구현된다. 

------------------------------------------------------------------------------------------------------------------
- JVM이란?

JVM(Java Virtual Machine)은 자바 프로그램을 실행시키는 도구
자바로 작성한 소스 코드를 해석해 실행하는 별도의 프로그램

- 프로그래밍 언어가 운영체제에 대해 종속성을 가지게 되는 이유 

프로그램이 실행되기 위해서는 컴퓨터 자원을 프로그램이 할당받아야 한다.
프로그램이 자신이 필요한 컴퓨터 자원을 운영체제에게 주문하면, 
운영체제는 가용한 자원을 확인한 뒤 프로그램이 실행되는 데에 필요한 컴퓨터 자원을 프로그램에게 할당
프로그램이 운영체제에게 필요한 컴퓨터 자원을 요청하는 방식이 운영체제마다 달라 문제가 발생

자바는 JVM을 매개로 해서 운영체제와 소통한다. 
JVM은 각 운영체제에 맞는 버전이 존재한다. 
JVM은 자바 소스 코드를 운영 체제에 맞게 변환해 실행시켜주기 때문에 
자바가 운영체제로부터 독립적으로 동작할 수 있다. 
------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------
- JVM 구조

자바 소스 코드를 작성하고 빌드 -> 컴파일러 실행되며 컴파일 완료 -> 결과 : .class인 클래스 파일
클래스 로더가 클래스 파일을 불러들이며 JVM이 동작 
Runtime Data Area에 데이터가 들어가며 프로그램이 실행
------------------------------------------------------------------------------------------------------------------
- JVM 메모리 구조

JVM에 Java 프로그램이 로드되어 실행될때 특정 값이나 데이터(바이트 코드, 객체, 변수 등)이 메모리에 저장
Runtime Data Area는 이러한 정보를 담는 메모리 영역, 크게 5가지 영역으로 나뉜다. 
Heap, Stack, Method Area, PC register, Native Method Stack

: https://deepu.tech/memory-management-in-jvm/
------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------
- Stack과 Heap
------------------------------------------------------------------------------------------------------------------
- Stack 영역이란?
일종의 자료구조
+) 자료구조 : 프로그램이 데이터를 저장하는 방식 

LIFO : Last In First Out, 마지막에 들어간 데이터가 가장 먼저 나온다. 

!) JVM 안에서의 Stack 동작 
메서드가 호출되면 해당 메서드를 위한 공간인 Method Frame이 생성된다. 
Method Frame에 메서드 내부에서 사용하는 다양한 값들(참조변수, 매개변수, 지역변수, 리턴값 및 연산시 일어나는 값)이 임시 저장된다.
Method Frame은 Stack에 호출되는 순서로 쌓이고, Method의 동작이 완료되면 역순으로 제거된다. 

------------------------------------------------------------------------------------------------------------------
- Heap 영역이란? 

JVM에는 단 하나의 Heap 영역이 존재하며, JVM이 작동될 때 자동 생성된다. 
Heap 영역에는 객체나 인스턴스 변수, 배열이 저장된다.
실제 객체의 값이 저장되는 공간 

ex) 인스턴스 생성

Person kimcoding = new Person( );

new Person( )이 실행되면, Heap 영역에 인스턴스가 생성된다.
kimcoding에게 인스턴스가 생성된 위치의 주소값을 할당해준다.
kimcoding은 Stack 영역에 선언되는 변수다. 

객체를 다룬다 : Stack 영역에 저장되어 있는 참조 변수를 통해 Heap 영역에 존재하는 객체를 다룬다. 
+) JVM의 Heap 영역의 객체는 대부분 일회성 
------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------
- Garbage Collection
------------------------------------------------------------------------------------------------------------------
- Garbage Collection이란?

메모리를 자동으로 관리하는 프로세스
가비지 컬렉션은 프로그램에서 더이상 사용하지 않는 객체를 찾아 삭제하거나 제거하여 메모리를 확보한다. 

Person programmer = new Person();
// 참조 변수 programmer은 Person 클래스의 인스턴스의 주소값을 할당받는다.

programmer.setName("김해커");
//“김해커”라는 문자열이 programmer가 가리키는 인스턴스의 name이라는 속성에 할당된다. 

programmer = null; 
// 가비지 발생! 
//참조 변수 programmer에 null을 할당-> 기존에 programmer가 가리키던 인스턴스와 참조변수 programmer 간의 연결이 끊어진다. 
//프로그램 실행 중에 이처럼 아무도 인스턴스를 참조하고 있지 않다면, 더 이상 메모리에 programmer가 가리키던 인스턴스가 존재할 이유가 없다.
//가비지 컬렉터는 어디에도 참조되고 있지 않은 객체나 변수들을 검색하여 메모리에서 점유를 해제해 메모리 공간을 확보한다. -> 메모리 효율적 사용 가능

programmer = new Person( ); 
programmer.setName("박코딩");
------------------------------------------------------------------------------------------------------------------
- 동작 방식 

JVM의 Heap 영역의 객체는 대부분 일회성이며, 메모리에 남아 있는 기간이 대부분 짧다는 전제로 설계되었다.
-> 객체가 얼마나 살아있느냐에 따라 Heap 영역 안에서도 영역을 나눈다. (Yound, Old 영역)

Young 영역 
: 새롭게 생성된 객체가 할당되는 곳, 많은 객체가 생성되었다 사라지기를 반복한다. 
  Young 영역에서 활동하는 가비지 컬렉터 : Minor GC 

Old 영역
: Young 영역에서 상태를 유지하고 살아남은 객체들이 복사되는 곳
  Young 영역보다 크게 할당되고, 크기가 큰 만큼 가비지는 적게 발생한다. 
  Old 영역에서 활동하는 가비지 컬렉터 : Major GC
------------------------------------------------------------------------------------------------------------------
Young 영역과 Old 영역은 서로 다른 메모리 구조를 가져 세부적인 동작 방식은 다르지만
기본적으로 가비지 컬렉션이 실행될 때는 아래의 2가지 단계를 따른다. 

1. Stop the World

가비지 컬렉션을 실행시키기 위해 JVM이 애플리케이션의 실행을 멈추는 작업
가비지 컬렉션이 실행될 때 가비지 컬렉션을 실행하는 쓰레드를 제외한 모든 쓰레드의 작업이 중단
가비지 정리가 완료되면 쓰레드 작업 재개

2. Mark and Sweep

두가지 일을 수행 
Mark : 사용되는 메모리와 사용하지 않는 메모리를 식별하는 작업
Sweep : Mark 단계에서 사용되지 않음으로 식별된 메모리를 해제하는 작업

Stopr the World로 모든 작업이 중단되면 
가비지 컬렉션이 모든 변수와 객체 탐색해 각각 어떤 객체를 참고하고 있는지 확인
사용되고 있는 메모리를 식별하고(Mark) 사용되지 않는 메모리는 제거(Sweep)하는 과정 진행        

------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------