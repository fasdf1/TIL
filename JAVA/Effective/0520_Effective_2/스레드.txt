--------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------
- 스레드(Thread)
한 가닥의 실 <- 순차적으로 실행한 코드가 실처럼 이어진다. 
하나의 스레드 : 하나의 코드 실행 흐름
( 한 프로세스 내에 스레드가 두 개라면 두 개의 코드 실행 흐름이 생긴다)
--------------------------------------------------------------------------------------------------------------------------------------------
- 멀티 스레드(Multi-Thread)
멀티 태스킹 : 두 가지 이상의 작업을 동시에 처리하는 것
운영체제는 멀티 태스킹을 할 수 있도록 CPU및 메모리 자원을 프로세스마다 적절히 할당해주고, 병렬로 실행

멀티 태스팅이 무조건 멀티 프로세스를 의미하지는 않는다. 
한 프로세스 내에서 멀티 태스킹할 수 있는 애플리케이션도 존재 

멀티 프로세스 :  애플리케이션 단위의 멀티 태스킹
멀티 스레드 :  애플리케이션 내부에서의 멀티 태스킹

멀티 스레드를 통해 하나의 프로세스가 두 가지 이상의 작업을 처리
--------------------------------------------------------------------------------------------------------------------------------------------
- 메인 스레드(main thread)
모든 자바 애플리케이션은 메인스레드(main thread)가 main() 메서드를 실행하면서 시작
메인 스레드는 main() 메서드의 첫 코드부터 아래로 순차적으로 실행하고, 
main() 메서드의 마지막 코드를 실행하거나 return 문을 만나면 실행을 종료

메인 스레드는 필요에 따라 작업 스레드들을 만들어서 동시에 실행할 수 있다. 
( 멀티 스레드를 생성해서 멀티 태스킹을 수행 ) 

싱글 스레드 애플리케이션에서는 메인 스레드가 종료하면 프로세스도 종료 
멀티 스레드 애플리케이션에서는 실행 중인 스레드가 하나라도 있다면 프로세스는 종료 되지 않는다. 
(메인 스레드가 작업 스레드보다 먼저 종료되더라도 작업 스레드가 계속 실행 중이라면 프로세스는 종료되지 않는다.)
--------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------
- Thread 생성과 실행
: 멀티 스레드 애플리케이션 : 몇 개의 작업을 동시에 실행할지 결정 -> 각 작업별로 스레드를 생성(메인 작업 이외에 추가적인 병렬 작업의 수)

- 작업 스레드 생성과 실행
자바에서는 작업 스레드도 객체로 생성->  클래스가 필요
--------------------------------------------------------------------------------------------------------------------------------------------
1. Thread 클래스로부터 직접 생성

: java.lang.Thread 클래스를 직접 객체화 해서 생성
 Runnable을 매개변수로 갖는 생성자를 호출

Thread thread = new Thread(Runnable target);
--------------------------------------------------------------------------------------------------------------------------------------------
Runnable : 작업 스레드가 실행할 수 있는 코드를 가지고 있는 객체,  함수형 인터페이스( run( ) 메서드 하나만 정의되어 있다)
Runnable은 인터페이스 타입이기 때문에 구현 객체를 만들어 대입
Runnable의 추상메서드를 구현 클래스에서 재정의-> 작업 스레드가 실행할 코드를 작성

class Test implements Runnable {
	public void run() {
		작업 스레드가 실행할 코드;
	}
}
--------------------------------------------------------------------------------------------------------------------------------------------
Runnable은 작업 내용을 가지고 있는 객체이지 실제 스레드가 아니다. 
Runnable 구현 객체를 생성한 후 이를 매개값으로 Thread 생성자를 호출해야 작업 스레드가 생성되는 것 

Runnable test= new Test();
Thread thread = new Thread(test);
--------------------------------------------------------------------------------------------------------------------------------------------
Thread 생성자를 호출할 때 Runnable 익명 객체를 매개변수로 사용할 수도 있다. -> 코드 간결

Thread thread = new Thread(new Runnable() {
	public void run() {
		스레드가 실행할 코드;
	}
});
--------------------------------------------------------------------------------------------------------------------------------------------
Runnable 인터페이스는 함수형 인터페이스 -> 람다식을 매개변수로도 사용 가능 

Thread thread = new Thread( ()-> {
	스레드가 실행할 코드;
});  

--------------------------------------------------------------------------------------------------------------------------------------------
작업 스레드는 생성 즉시 실행되지 않는다. (start() 메서드를 호출해줘야 실행)

thread.start();
-> 작업 스레드는 매개변수로 받은 Runnable의 run() 메서드를 실행하면서 자신의 작업을 처리
--------------------------------------------------------------------------------------------------------------------------------------------

2. Thread 하위 클래스로부터 생성 
: Thread를 상속해서 하위 클래스를 만들어 생성
  작업 스레드가 실행할 작업을 Runnable로 만들지 않고 Thread의 하위 클래스로 작업 스레드를 정의하면서 작업 내용을 포함
--------------------------------------------------------------------------------------------------------------------------------------------
Thread 클래스를 상속한 후 run 메서드를 재정의(overriding)해서 스레드가 실행할 코드를 작성

public class WorkerThread extends Thread {
	@Override
	public void run() {
		//스레드가 실행할 코드
	}
}

Thread thread = new WorkerThread();
--------------------------------------------------------------------------------------------------------------------------------------------
Thread 익명 객체로 작업 스레드 객체를 생성

Thread thread = new Thread(){
	public void run(){
		스레드가 실행할 코드;
	}
}
--------------------------------------------------------------------------------------------------------------------------------------------
작업 스레드 객체에서 start() 메서드를 호출 -> 자신의 run() 메서드를 실행

thread.start();
--------------------------------------------------------------------------------------------------------------------------------------------
- 스레드의 이름 
thread.setName("Thread Name");
thread.getName();

setName()과 getName() : Thread의 인스턴스 메서드, 스레드 객체의 참조가 필요
currentThread() : Thread의 정적 메서드,  코드를 실행하는 현재 스레드의 참조를 얻는다. 
--------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------
- Thread 동기화 및 상태
--------------------------------------------------------------------------------------------------------------------------------------------
- 동기화 메서드와 동기화 블록

: 멀티 스레드 프로그램에서는 스레드들이 객체를 공유해서 작업
스레드가 사용 중인 객체를 다른 스레드가 변경할 수 없도록 하려면 
스레드 작업이 끝날 때까지 객체에 잠금을 걸어서 다른 스레드가 사용할 수 없도록 해야 한다. 

임계 영역 : 멀티 스레드 프로그램에서 단 하나의 스레드만 실행할 수 있는 코드 영역
자바는 임계 영역을 지정하기 위해서 동기화 메서드와 동기화 블록을 제공
스레드가 객체 내부의 동기화 메서드 혹은 블록에 들어가면 즉시 객체에 잠금을 걸어 다른 스레드가 임계 영역 코드를 실행하지 못하도록 설정
동기화 메서드는 메서드 선언에 synchronized 키워드를 붙여서 만든다. (인스턴스와 정적 메서드에 모두 사용 가능한 키워드)

--------------------------------------------------------------------------------------------------------------------------------------------
- 스레드의 상태 
스레드 객체를 생성하고, start() 메서드를 호출하면 실행 대기 상태가 된다. (스케줄링이 되지 않아서 실행을 기다리고 있는 상태)
실행 대기 상태에 있는 스레드 중에서 스레드 스케줄링으로 선택된 스레드가 CPU를 점유하고 run( ) 메서드를 실행한다 -> 실행(Running) 상태
실행 상태의 스레드는 run( )메서드를 모두 실행하기 전에 스레드 스케줄링에 의해 다시 실행 대기 상태로 돌아갈 수 있다. 
그리고 실행 대기 상태에 있는 다른 스레드가 선택되어 실행 상태로 바뀐다. 
스레드는 실행 대기 상태와 실행 상태를 번갈아 가면서 자신의 run() 메서드를 조금씩 실행한다. 
실행 상태에서 run() 메서드가 종료되면, 더 이상 실행할 코드가 없기 때문에 스레드의 실행 멈춤 -> 종료 상태

실행 상태 ->  일시 정지 상태 (스레드 실행할 수 없는 상태) -> 실행 상태로 가기 위해서 실행 대기 상태로 가야 한다. 

getState() 메서드 : 스레드의 상태 확인하는 메서드 
                         Thread.State 열거 상수 (NEW, RUNNABLE, WAITING, TIMED_WAITING, BLOCKED, TERMINATED)를 리턴
--------------------------------------------------------------------------------------------------------------------------------------------
- 스레드 상태 제어
--------------------------------------------------------------------------------------------------------------------------------------------
1. 주어진 시간동안 일시 정지(sleep())
정적 메서드 sleep()은 실행 중인 스레드를 일정 시간 멈추게 한다. 
일시정지 상태로 지속 시간 : 밀리세컨드 단위
!) 일시 정지 상태에서 주어진 시간이 되기 전에 interrupt() 메서드가 호출되면 
   InterruptedException이 발생하기 때문에 예외처리가 필요

try {
	Thread.sleep(1000);
} catch (InterruptedException e){
	//interrupt() 메서드가 호출되면 실행
}
--------------------------------------------------------------------------------------------------------------------------------------------

2. 다른 스레드에게 실행 양보(yield())

스레드가 처리하는 작업: 반복적 실행 포함하는 경우가 많다. 
반복문이 무의미한 반복을 하는 경우 yield()메서드를 호출해 무의미한 반복 실행을 다른 스레드에게 양보하고 
해당 스레드는 실행 대기 상태로 만들 수 있다. 
yield() 메서드를 호출한 후 동일한 우선순위 또는 높은 우선순위를 갖는 다른 스레드가 실행기회를 가진다. 
--------------------------------------------------------------------------------------------------------------------------------------------
3. 다른 스레드의 종료를 기다림(join())

join( ) 메서드 : 다른 스레드가 종료될 때까지 기다렸다가 실행
--------------------------------------------------------------------------------------------------------------------------------------------
4. 스레드 간 협업(wait(), notify(), notifyAll())

두 개의 스레드를 교대로 번갈아가며 실행해야 할 경우
자신의 작업이 끝나면 상대방 스레드를 일시정지 상태에서 풀어주고, 자신은 일시 정지 상태로 만든다. 
-> 공유 객체 : 두 스레드가 작업할 내용을 각각 동기화 메서드로 구분
-> 한 스레드가 작업을 완료하면 notify() 메서드를 호출
-> 일시 정지 상태에 있는 다른 스레드를 실행 대기 상태로 만든다
-> 자신은 두 번 작업을 하지 않도록 wait() 메서드를 호출하여 일시 정지 상태

!) 만약 wait() 대신 wait(long timeout)이나, wait(long timeout, int nanos)를 사용하면 
  notify()를 호출하지 않아도 지정된 시간이 지났을 때 스레드가 자동적으로 실행 대기 상태로 바뀐다. 

+) notify() vs notifyAll()
notify()는 wait()에 의해 일시 정지된 스레드 중 한 개를 실행 대기 상태로
notifyAll() 메서드는 wait()에 의해 일시 정지된 모든 스레드들을 실행 대기 상태로 

이 메서드들은  Object 클래스에 선언된 메서드 -> 모든 공유 객체에서 호출이 가능
!) 주의할 점 : 동기화 메서드 또는 동기화 블록 내에서만 사용 가능
--------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------
- Thread 풀
동시 작업 처리가 많아지만 스레드 수가 증가하고 
스레드 생성과 스케줄링으로 인해 메모리 사용량 늘어난다 -> 성능 저하 

스레드의 무분별한 증가를 방지하기 위해 스레드풀을 사용한다. 
스레드풀은 작업 처리에 사용되는 스레드의 수를 정해 놓는다. 
큐에 작업이 들어오면 스레드풀 안에 스레드가 하나씩 맡아서 처리한다.
작업 처리가 끝난 스레드는 작업 큐의 새로운 작업을 처리한다. 
--------------------------------------------------------------------------------------------------------------------------------------------
- 스레드풀 생성 

ExecutorService(스레드 풀) 구현 객체는 Executors 클래스 메서드로 생성할 수 있다. 

메서드				초기 스레드 수	코어 스레드 수	최대 스레드 수
newCachedThreadPool()		0		0		Integer.MAX_VALUE
newFixedThreadPool(int num)	0		num		num
--------------------------------------------------------------------------------------------------------------------------------------------
- 스레드풀 종료 
스레드풀은 main 스레드가 종료되어도 작업을 처리하기 위해 계속 실행 상태로 남아있다.
애플리케이션을 종료하기 위해서는 스레드풀을 종료해야 한다. 

메서드					리턴타입	설명
shutdown()				void	작업 큐에 남아있는 모든 작업을 처리한 뒤 종료
shutdownNow()				List	작업 큐에 남아있는 작업과 상관없이 종료, 처리 못한 작업(Runnable) 목록을 리턴
awaitTermination(long timeout, TimeUnit unit)	boolean	shotdown() 메소드 호출 후, 모든 작업 처리를 timeout 시간 안에 완료되면 true, 
 								           완료되지 않으면 작업 스레드들을 interrupt()하고 false 리턴


--------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------