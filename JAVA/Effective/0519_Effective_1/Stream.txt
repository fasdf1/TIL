---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------
스트림(Stream)
배열, 컬렉션의 저장 요소를 하나씩 참조해서 람다식으로 처리할 수 있도록 해주는 '반복자'
List, Set, Map, 배열 등 다양한 데이터 소스들을 스트림으로 만들 수 있다.

스트림의 데이터 소스를 다루는 메서드를 활용
-> 다량의 데이터에 복잡한 연산 수행 가능 
-> 가독성과 재사용성이 높은 코드를 작성 가능
---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------
- 스트림의 특징
---------------------------------------------------------------------------------------------------------------------------------
1. 선언형으로 데이터 소스 처리

선언형 프로그래밍
: 어떻게 수행 < 무엇을 수행 
 어떻게 -> 추상화 
 내부 동작 원리를 모르더라도 코드의 역할 이해 가능

-> 명령형 방식보다 선언형 방식(Stream)이 훨씬 단순하고 가독성이 높음
---------------------------------------------------------------------------------------------------------------------------------
2. 요소 처리 코드를 람다식으로 제공

Stream이 제공하는 대부분의 요소 처리 메서드는 함수형 인터페이스 매개타입을 가진다. 
-> 람다식 or 메서드 참조를 이용해서 요소 처리 내용을 매개값으로 전달할 수 있다. 
---------------------------------------------------------------------------------------------------------------------------------
3. 병렬 처리가 쉬움 ( 내부 반복자 사용 )

외부반복자(external iterator) 
: 개발자가 코드로 직접 컬렉션의 요소를 반복해서 가져오는 코드 패턴
ex) for문의 index, Iterator 이용하는 while문

내부 반복자(internal iterator)
: 컬렉션 내부에서 요소들을 반복시키고 개발자는 요소당 처리해야할 코드만 제공하는 코드 패턴

내부 반복자의 장점  : 개발자는 요소 처리 코드에만 집중할 수 있다
내부 반복자는 요소들의 반복 순서를 변경하거나 멀티 코어 CPU를 최대한 활용하기 위해 요소들을 분배시켜 
병렬 작업을 할 수 있게 도와주기 때문에 하나씩 처리하는 순차적 외부 반복자보다 '효율적'으로 요소를 반복시킬 수 있습니다. 

+) 병렬 처리:  한 가지 작업을 서브 작업으로 나누고, 서브 작업들을 분리된 스레드에서 병렬적으로 처리하는 것
---------------------------------------------------------------------------------------------------------------------------------
4. 컬렉션의 요소에 대해 중간 연산과 최종 연산 수행 가능
중간 연산:  매핑, 필터링, 정렬, 그루핑 등 수행 
최종 연산:   반복, 카운팅, 평균, 총합, 최대 / 최소값 등 등의 집계 수행

ex) 학생 객체를 요소로 가지는 컬렉션 
중간 연산: 학생의 점수 추출
최종 연산: 점수의 평균값 산출
---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------
- 파이프라인 구성(.)

리덕션(Reduction) :대량의 데이터를 가공해서 축소하는 것
리덕션의 결과물 : 데이터의 합계, 평균값, 카운팅, 최대값, 최소값 등
!) 컬렉션의 요소를 리덕션의 결과물로 바로 집계할 수 없을 때 중간 연산 필요 

- 파이프라인 : 여러개의 스트림이 연결되어 있는 구조
스트림은 중간 연산과 최종 연산을 파이프라인(pipelines)으로 해결
파이프라인에서 최종 연산을 제외한 것들은 모두 중간 연산 스트림
---------------------------------------------------------------------------------------------------------------------------------
중간 스트림이 생성될 때 '요소들'은 바로 중간 연산(필터링, 매핑, 정렬)되는 것이 아니라 최종 연산이 시작되기 전까지는 지연된다.
최종 연산이 시작되면 비로소 컬렉션의 요소가 하나씩 중간 스트림에서 연산되고 최종 연산까지 오게 된다.

Stream 인터페이스에서 중간 연산 메서드들은 중간 연산된 스트림을 리턴한다. 
그리고 이 스트림에서 다시 중간 연산 메소드를 호출해서 파이프라인을 형성한다. 
---------------------------------------------------------------------------------------------------------------------------------
ex) 회원 컬렉션
중간 스트림(남자만 필터링) 연결 -> 중간 스트림(남자의 나이로 매핑) 연결 -> 최종 스트림(남자 평균 나이) -> 파이프라인 형성 
---------------------------------------------------------------------------------------------------------------------------------
- 파이프라인 코드 

Stream<Member> maleFemaleStream = list.stream();
Stream<Member> maleStream = maleFemaleSTream.filter(m -> m.getGender() == Member.MALE);
// .filter(m-> m.getGender() == Member.MALE) : 남자 Member 객체를 요소로 하는 새로운 스트림을 생성

IntStream ageStream = maleStream.mapToInt(Member::getAge);
// .mapToInt(Member::getAge) :  Member 객체를 age 값으로 매핑해서 age를 요소로 하는 새로운 스트림을 생성

OptionalDouble opd = ageStream.average();
: age 요소의 평균을 OptionalDouble에 저장

double ageAve = opd.getAsDouble();
// OptionalDouble에 저장된 평균 값을 읽기 위해 getAsDouble() 메소드를 호출
---------------------------------------------------------------------------------------------------------------------------------
- 로컬 변수 생략한 뒤 연결한 파이프라인 코드 

double ageAve = list.stream()                       //오리지널 스트림

.filter(m-> m.getGender() == Member.MALE)    //중간 연산 스트림
.mapToInt(Member::getAge)                         //중간 연산 스트림

.average()                                                //최종 연산
.getAsDouble();

 
---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------
- 스트림 생성/ 중간 연산/ 최종 연산 
---------------------------------------------------------------------------------------------------------------------------------
1. 스트림 생성
Collection 인터페이스에는 stream()이 정의
Collection 인터페이스를 구현한 객체들(List, Set 등)은 stream() 메서드를 이용해 스트림 생성 가능 
stream() : 해당 Collection의 객체를 소스로 하는 Stream을 반환

- List로부터 스트림을 생성
List<String> listExample = Arrays.asList("Z", "X", "C");
Stream<String> listStream = listExample.stream();
listStream.forEach(System.out::prinln); 

- 배열로부터 스트림 얻기 : 
Stream<String> stream = Stream.of("Z", "X", "C"); //가변인자
Stream<String> stream = Stream.of(new String[] {"Z", "X", "C"});
Stream<String> stream = Arrays.stream(new String[] {"Z", "X", "C"});
Stream<String> stream = Arrays.stream(new String[] {"Z", "X", "C"}, 0, 3); //index

- 숫자로부터 스트림 얻기
원시 자료형(int, long, double 등)들을 사용하기 위한 특수한 종류의 Stream(IntStream, LongStream, DoubleStream)들도 사용 가능
Intstream은 range()함수를 사용하여 for문을 대체 가능
IntStream stream = IntStream.range(2, 8);  // 2 이상 8 미만 

!) 주의점
스트림은 Read-only( 데이터 소스로부터 데이터를 읽기만 할 뿐 변경하지 않는다)
스트림은 일회용( 한 번 사용하면 닫히므로, 필요하다면 새로운 스트림을 만들어야 한다)
---------------------------------------------------------------------------------------------------------------------------------
2. 중간 연산
: 연산 결과를 스트림으로 반환 -> 연속해서 여러 번 수행 가능

2-1. 필터링(filter(), distinct())

distinct() : Stream의 요소들에 중복된 데이터가 존재하는 경우, 중복을 제거하기 위해 사용
filter() : Stream에서 조건에 맞는 데이터만을 정제하여 더 작은 컬렉션을 만들어 낸다. 
           매개값으로 조건(Predicate)이 주어지고, 조건이 참이 되는 요소만 필터링
---------------------------------------------------------------------------------------------------------------------------------
★2-2. 매핑(map())

- map( )
: map은 기존의 Stream 요소들을 대체하는 요소로 구성된 새로운 Stream을 형성

기존 스트림 : B , A ---> B-> C, A->D --> 새로운 스트림: C, D

저장된 값을 특정한 형태로 변환하는데 주로 사용
Java에서는 map 함수의 인자로 함수형 인터페이스 function을 받는다.  
map()이외에도 mapToInt(), mapToLong(), mapToDouble() 등의 메서드가 있다. 
mapOOO() 메서드는 일반적인 Stream 객체를 원시 Stream으로 바꾸거나 그 반대로 하는 작업이 필요한 경우에 사용
반대로 원시 객체는 -> 일반적인 Stream 객체 : mapToObject를 통해 변환 가능

- flatMap( )
: flatMap은 요소를 대체하는 복수 개의 요소들로 구성된 새로운 스트림을 리턴

기존 스트림 : B , A ---> A : A1,A2, B: B1, B2 --> 새로운 스트림: A1,A2,B1,B2


!) flatMap( ) vs map( )
 map()은 스트림의 스트림( Stream<Stream>)을 반환하는 반면, flatMap()은 스트림(Stream)을 반환
 
---------------------------------------------------------------------------------------------------------------------------------
2-3. 정렬(sorted())
: Stream의 요소들을 정렬
파라미터로 Comparator를 넘길 수도 있다. 
ex)  .sorted(Comparator.reverseOrder())

Comparator 인자 없이 호출할 경우에는 오름차순으로 정렬
Comparator의 reverseOrder를 이용하면 내림차순으로 정렬

---------------------------------------------------------------------------------------------------------------------------------
2-4. 연산 결과 확인(peek())
: 주로 연산 중간에 결과를 확인하여 디버깅하고자 할 때 사용
intStream
	.filter(a -> a%7 ==0)
	.peek(n-> System.out.println(n))
	.sum();

!) peek( ) vs forEach()
peek(), forEach()는 요소를 하나씩 돌면서 출력
기능 동일, 작동 방식 다름
peek은 중간 연산 메서드이고, forEach는 최종 연산 메서드
forEach는 스트림의 요소를 소모하므로 한 번만 호출 가능 (재호출 원하면 새로운 스트림 생성)
peek은 중간 연산이므로 하나의 스트림에 여러 번 사용 가능 
---------------------------------------------------------------------------------------------------------------------------------

3. 최종 연산
: 연산 결과가 스트림이 아니므로, 한 번만 연산이 가능

3-1. 연산 결과 확인(forEach())
: 최종 연산 메서드 -> 파이프라인 마지막에서 요소를 하나씩 연산
출력할 때 주로 사용하지만 리턴 값이 없는 작업(이메일 발송, 스케줄링 등)에서도 사용 가능
intStream
	.filter(a -> a%7 ==0)
	.forEach(n -> System.out.println(n));

---------------------------------------------------------------------------------------------------------------------------------
3-2. 매칭(match())
: Stream의 요소들이 특정한 조건을 충족하는지 검사하고 싶은 경우 사용
함수형 인터페이스 Predicate를 받아서 해당 조건을 만족하는지 검사하고, 검사 결과를 boolean으로 반환

3가지의 메서드 
allMatch() : ' 모든 요소들 '이 매개값으로 주어진 Predicate의 조건을 ' 만족하는지 ' 조사
anyMatch() : ' 최소한 한 개의 요소 '가 매개값으로 주어진 Predicate의 조건을 ' 만족하는지 ' 조사
noneMatch() : ' 모든 요소들 '이 매개값으로 주어진 Predicate의 조건을 ' 만족하지 않는지 ' 조사

boolean result = Arrays.stream(inArr).allMatch(a->a%7==0);
boolean result = Arrays.stream(inArr).anyMatch(a->a%7==0);
boolean result = Arrays.stream(inArr).noneMatch(a->a%7==0);

---------------------------------------------------------------------------------------------------------------------------------
3-3. 기본 집계(sum(), count(), average(), max(), min())
: 요소들을 카운팅, 합계, 평균값, 최대값, 최소값 등으로 연산하여 하나의 값으로 산출하는 것
  count()와 sum() 등 집계 메서드는 내부적으로 모두 reduce()를 사용
---------------------------------------------------------------------------------------------------------------------------------
★3-4. Reduce
다양한 집계 결과물을 만들 수 있다. 
누적하여 하나로 응축(reduce)하는 방식으로 동작
앞의 두 요소의 연산 결과를 바탕으로 다음 요소와 연산

최대 3개의 매개변수를 받을 수 있다. 

1. Identity: 계산을 수행하기 위한 초기값
2. Accumulator: 각 요소를 계산한 중간 결과를 생성하기 위해 사용
3. Combiner: 병렬 스트림(Parlallel Stream)에서 나누어 계산된 결과를 하나로 합치기 위한 로직

첫 연산 : 초기값과 스트림의 첫 번째 요소 연산
!) 초기값이 없는 reduce는 스트림의 첫 번째 요소와 두 번째 요소로 첫 연산을 수행

---------------------------------------------------------------------------------------------------------------------------------
★3-5. Collect()
Stream의 요소들을 List나 Set, Map, 등 다른 종류의 결과로 수집하고 싶은 경우 사용
collect 메서드는 어떻게 Stream의 요소들을 수집할 것인가를 정의한 Collector 타입을 인자로 받는다. 
Collector 인터페이스를 구현한 클래스

일반적으로 List로 Stream의 요소들을 수집
자주 사용하는 작업은 Collectors 객체에서 static 메서드로 제공
Collector 인터페이스를 직접 구현하여 사용할 수도 있다. 

---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------
- Optional<T>
 NullPointerException(NPE), 즉 null 값으로 인해 에러가 발생하는 현상을 객체 차원에서 효율적으로 방지하고자 도입
연산 결과를 Optional에 담아서 반환하면, 따로 조건문을 작성해주지 않아도 NPE가 발생하지 않도록 코드를 작성할 수 있다. 

- Optional 클래스
 : 모든 타입의 객체를 담을 수 있는 래퍼(Wrapper) 클래스

public final class Optional<T> {
	private final T value; // T타입의 참조변수
}

- Optional 객체 생성 : of() 또는 ofNullable()을 사용
!) 참조변수의 값이 null일 가능성이 있다면, ofNullable()을 사용

Optional<String> optn1 = Optional.ofNullable(null);
Optional<String> optn2 = Optional.ofNullable("123");
System.out.println(optn1.isPresent()); //Optional 객체의 값이 null인지 여부를 리턴
System.out.println(optn2.isPresent());

- Optional 타입의 참조변수를 기본값으로 초기화 : empty() 메서드를 사용

Optional<String> optn3 = Optional.<String>empty();

- Optional 객체에 객체에 저장된 값을 가져오기 :  get()을 사용
!) 참조변수의 값이 null일 가능성이 있다면 orElse()메서드를 사용해 디폴트 값을 지정

Optional<String> optnString = Optional.of("codestates");
System.out.println(optnString);
System.out.println(optnString.get());

String nullValue = null;
String subject = Optional.ofNullable(nullValue).orElse("MATH");
System.out.println(subject);

- Optional 객체는 스트림과 유사하게 여러 메서드를 연결해 작성 가능 (메서드 체이닝)

---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------
-  컬렉션 vs 스트림
데이터에 복잡한 가공 처리가 필요할 때 : 스트림 사용
컬렉션은 즉시 작업을 수행하지만(Eager), 스트림은 필요에 따라 데이터가 지연(Lazy)되고, 단락 평가(Short-circuit)된다
Eager는 메모리에 전체를 한 번에 올려서 처리
Lazy는 필요할 때에만 조금씩 올리면서 처리 // 대용량 데이터를 처리할 때 성능상 이점 

지연 평가( lazy evaluation ): 최종 연산을 호출해야 그때서야 작업 한다.

단락 평가( Short-circuit ) : 무한 스트림을 유한하게 연산할 수 있도록 해주는 제어 방식
                                 limit()메서드를 이용해 스트림이 n개 이상 연산하지 않도록 해주는 평가 전략

IntStream intStream = new Random().ints(); //무한 스트림
intStream.limit(5).forEach(System.out::println); // 5개의 요소만 출력한다.
---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------
