--------------------------------------------------------------------------------------------------
캡슐화(Encapsulation)
: 특정 객체 안에 관련된 속성과 기능을 하나의 캡슐로 만들어 데이터를 외부로부터 보호하는 것
--------------------------------------------------------------------------------------------------
캡슐화의 이유
1. 데이터 보호
2. 내부적으로만 사용되는 데이터에 대한 불필요한 외부 노출 방지 
--------------------------------------------------------------------------------------------------
캡슐화의 장점 :정보 은닉(Data Hiding) 
1. 외부로부터 객체의 속성과 기능이 함부로 변경되지 못하게 막는다
2. 독립성 확보(데이터가 변경되더라도 다른 객체에 영향을 주지 않는다.)
3. 유지보수/코드 확장 시 오류 범위 최소화되어 유지보수 용이
--------------------------------------------------------------------------------------------------
- 패키지
특정한 목적을 공유하는 클래스와 인터페이스의 묶음
클래스들을 그룹 단위로 묶어 효과적으로 관리하기 위한 목적으로 사용
자바에서 패키지는 물리적인 하나의 디렉토리
계층 구조로 구성, 계층 구조간 구분은 점(.)으로 표현

패키지가 있는 경우: 첫 번째 줄에 반드시 ‘package 패키지명'을 표시해야 한다. 
패키지 선언이 없는 경우: 이름없는 패키지에 속한다.

ex) 패키지가 있는 경우
package Examplepack.test; // 패키지 구문 포함. 패키지가 없다면 구문 필요없음

public class TestPack {

}
--------------------------------------------------------------------------------------------------
- 자바의 기본 패키지
java.lang : 자바의 기본 클래스들
java.util : 확장 클래스
java.io / java.nio : 자바의 입출력과 관련된 클래스

ex) String 클래스 -> java.lang.String 
--------------------------------------------------------------------------------------------------
- import문
다른 패키지 내의 클래스를 사용하기 위해 사용
패키지 구문과 클래스문 사이에 작성

import 패키지명.클래스명; 
            or
import 패키지명.*;
--------------------------------------------------------------------------------------------------
!) Package ExamplePack.test 안에 TestPack이라는 클래스가 존재
--------------------------------------------------------------------------------------------------
- import문을 사용하지 않고 다른 패키지에 있는 클래스를 사용하려는 상황

ex) 
TestPack tp1 = new TestPack( );  [ X]
Package ExmamplePack.test.TestPack tp1 = new ExmamplePack.test.TestPack( ); [ O ]
--------------------------------------------------------------------------------------------------
- import문을 사용하는 경우 
import ExamplePack.test.TestPack //import문 작성

TestPack tp2 = new TestPack( );  // 패키지명 생략 가능 
--------------------------------------------------------------------------------------------------
- 제어자(Modifier)
자바에서 제어자는 클래스, 필드, 메서드, 생성자 등에 부가적인 의미를 부여하는 키워드
접근 제어자와 기타 제어자로 구분된다. 

접근 제어자	public, protected, (default), private
기타 제어자	static, final, abstract, native, transient, synchronized 등

하나의 대상에 대해서 여러 제어자를 사용할 수 있지만, 
접근제어자는 각 대상에 대해 한 번만 사용할 수 있다. 
--------------------------------------------------------------------------------------------------
- 접근 제어자(Access Modifier)
--------------------------------------------------------------------------------------------------
접근 제어자	접근 제한 범위
--------------------------------------------------------------------------------------------------
private		동일 클래스에서만 접근 가능
default		동일 패키지 내에서만 접근 가능
protected	동일 패키지 + 다른 패키지의 하위 클래스에서 접근 가능
public		접근 제한 없음
--------------------------------------------------------------------------------------------------
public > protected > default > private
+) default는 아무런 접근 제어자를 붙이지 않는 것 
--------------------------------------------------------------------------------------------------
- getter와 setter 메서드
캡슐화의 목적을 달성하면서도 데이터의 변경이 필요한 경우 사용
ex) private 접근제어자가 포함되어 있는 객체의 변수에 데이터 값을 추가하거나 수정하고 싶을 때 getter와 setter 사용

- setter 메서드 
: 외부에서 메서드에 접근하여 조건에 맞을 경우 데이터 값을 변경 가능하게 해준다. 
  일반적으로 메서드명에 set~를 붙여서 정의  ex) setAge( )

-getter 메서드
:  설정한 특정 데이터를 읽어오는 데 사용
 객체 외부에서 필드 값을 사용하기에 부적절한 경우 그 값을 가공한 이후에 외부로 전달하는 역할
 get~을 메서드명 앞에 붙여서 사용한다.  ex) getId( )

!) 다른 클래스에서 private으로 선언되어 있는 객체의 값을 직접 바꾸려고 하면
  'name' has private access in 'Worker' 라는 메세지가 출력    
--------------------------------------------------------------------------------------------------
