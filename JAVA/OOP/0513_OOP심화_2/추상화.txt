=========================================================================
추상화 : 사물이나 표상을 어떤 성질, 공통성, 본질에 착안하여 그것을 추출하여 파악하는 것
-> ' 공통성과 본질을 모아 추출 '
-> 자바에서의 추상화는 객체의 공통적인 속성과 기능을 추출하여 정의하는 것
-> 기존 클래스들의 공통적인 요소들을 뽑아서 상위 클래스를 만들어 낸다.
-----------------------------------------------------------------------------------------------------------------
-장점
1. 코드 중복 최소화
2. 클래스 간의 관계 설정을 통해 유지/보수 용이
=========================================================================

-abstract 제어자

자바 -> abstract = 미완성 
abstract가 메서드 앞에 붙으면 추상 메서드, 
             클래스 앞에 붙으면 추상 클래스

ex)
abstract class TestAbstract {
	abstract void run( );  // 메서드 바디가 x -> 추상 메서드 
}

+) 어떤 클래스에 추상 메서드가 포함되어 있으면 해당 클래스는 추상 클래스
+) 추상 클래스는 미완성 상태 -> 메서드 바디가 완성되기 전까지 추상 클래스 기반의 객체 생성이 불가능
 =========================================================================

- 추상 클래스
메서드 시그니처만 존재하고 바디가 선언되어있지 않은 추상 메서드를 포함하는 ‘미완성 설계도

- 추상 클래스를 사용하는 이유?
1. 상속 관계에서 새로운 클래스 작성에 유용
: 메서드의 내용이 상속을 받는 클래스에 따라 달라지기 때문에 상위 클래스에서는 선언부만 작성
  상속을 받는 하위 클래스에서 각 상황에 맞는 구체적인 내용을 구현 -> 오버라이딩 

2. 추상화 구현의 핵심적인 역할 

+) 추상화 정도 : 상속계층의 상층부로 갈수록 추상화의 정도가 높고, 아래로 갈수록 구체화된다. 
=========================================================================

-final 키워드 
: final 제어자가 추가되면 해당 대상은 변경/확장이 불가능
final 키워드는 필드, 지역 변수, 클래스 앞에 위치하며 위치에 따라 의미가 달라진다. 

final 클래스 : 변경이나 확장이 불가능한 클래스, 상속 불가
final 메서드 : 오버라이딩 불가
final 변수    : 값 변경 불가

ex)
final class FinalTest { // 확장/상속/변경 불가
     final int num = 10 ; //상수

     final void printNum( ) {  //오버라이딩 불가 메서드 
	final int localNum =5; 
            System.out.prinlnt(localNum);
    }
}
=========================================================================

- 인터페이스
사물과 사물 사이 또는 사물과 인간 사이의 경계에서, 상호 간의 소통을 위해 만들어진 물리적 매개체나 프로토콜

!) 추상 클래스와의 차이점
인터페이스가 더 높은 추상성을 가지고 있다. 
추상 클래스는 구현부가 미완성돈 추상 메서드와 멤버 변수를 포함할 수 있지만
인터페이스는 오직 추상 메서와 상수만을 멤버로 가질 수 있다. 
-----------------------------------------------------------------------------------------------------------------
- 인터페이스의 구조

class 키워드 대신 interface 키워드를 사용
내부의 모든 필드가 public static final로 정의된다. 
static과 default 메서드 이외의 모든 메서드가 public abstarct로 정의된다
+) 모든 인터페이스의 필드와 메서드에는 위의 요소가 내포되어있기 때문에 명시하지 않아도 생략이 가능

ex) 
public interface TestInterface {
	public static final int num1 = 1; //인터페이스 인스턴스 변수 정의
 	final int num2 = 2; 
            static int num3 = 3;               // 생략 가능

	public abstarct void printNum( );
	void exit( );                          // public abstract 생략 가능
}

-----------------------------------------------------------------------------------------------------------------
- 인터페이스의 구현

클래스가 어떤 인터페이스를 구현한다 = 인터페이스가 가진 모든 추상 메서드들을 클래스 내에서 오버라이딩한다.
인터페이스 구현 시 implements 키워드를 사용한다. 

class TestImpleClass implements TestInterface {   . . . }

!) 상속과 달리 인터페이스는 하나의 클래스가 여러 개의 인터페이스를 구현할 수 있다.
: 인터페이스는 미완성된 멤버를 가지기 때문에 충돌의 여지가 없다 

class TestImpleClass implements TestInterface1, TestInterface2, TestInterface3 {   . . . }

+)  클래스를 상속받으면서 동시에 인터페이스 구현도 가능하다. 

=========================================================================