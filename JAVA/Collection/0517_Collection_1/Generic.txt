----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
Java의 모든 클래스는 Object클래스를 상속받아 확장된다. 

ex) 다양한 타입을 하나의 클래스에 넣기 ( 제네릭 사용X), 모든 클래스의 최상위 클래스인 Object 클래스로 선언

public class Box {
    private Object object;
    Box(Object object){ this.object = object; }
    public void set(Object object) { this.object = object; }
    public Object get() { return object; }
}

Box box = new Box( );
box.set("ABC");
box.set(5);
box.set('P');

!) set 메서드를 통해 다양한 타입을 넣을 수 있다.

!) 하지만 여러 타입을 사용하기 위해서는 수동 타입 변환이 빈번히 발생하고, 이로 인해 코드가 복잡해진다.
   또한 잘못된 수동 타입 변환은 에러를 발생시킨다.

ex) Box box = new Box("ABC");
    String str1 = (String) box.get( );  // 가능
    String str2 = (Integer) box.get( ); // 문자열 -> 정수 수동타입변환 불가 -> ClassCastExeption 발생

-> 제네릭 추가  
----------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------
- 제네릭
클래스 내부에서 사용할 데이터 타입을 외부에서 파라미터 형태로 지정하면서 데이터 타입을 일반화한다.
제네릭 없이 객체에 여러 자료형을 받으려면 int, float, string 등 모든 자료형에 대해 각각의 클래스를 하나씩 만들어야 한다.
하지만 제네릭을 사용하면 가상의 자료형을 정의 후, 객체를 정의할 때 타입 매개변수를 선언하여 사용할 수 있다.
----------------------------------------------------------------------------------------------------------------------
- 제네릭의 장점
타입체크와 형변환을 생략 -> 코드가 간결해진다.
클래스나 메서드 내부에서 사용되는 객체의 타입 안정성을 제공한다. 
----------------------------------------------------------------------------------------------------------------------
- 작성 방법 
제네릭은 여러 참조 자료형을 사용해야 하는 경우 하나의 문자로 표현한다. 
클래스 및 인터페이스 이름 뒤에 <> 안에 타입 파라미터를 넣어 작성
public class 클래스명<타입 매개변수>{ ... }
public interface 인터페이스명<타입 매개변수>{ ... }

public class Box<T> { }
public interface Box<V,R> { }
----------------------------------------------------------------------------------------------------------------------
- 자주 사용하는 타입 매개변수
타입인자	  설명
<T>	  Type
<E>	  Element
<K>	  Key
<N>	  Number
<V>	  Value
<R>	  Result
----------------------------------------------------------------------------------------------------------------------
public class Box<T> {  // 템플릿 형태의 제네릭 클래스 정의
     private T t;  //필드의 값을 T로 작성
     public T get( ) { return t; }  //메서드 리턴 값을 T로 작성
     public void set( T t ) { this.t = t;} 
     //속성과 메서드 정의
}

public class Main{ 
   public static void main(String[ ] args){
          Box<String> box1 = new Box<String>( );  //제네릭 객체를 생성할 때 어떤 타입의 값을 넣을지 결정
          box1.set("ABC");                                 // 제네릭 객체 사용
          String str1 = box1.get( );
        
          Box<Integer> box2 = new Box<Integer>( );
          box2.set(100);
          String iValue = box2.get( );
     }
}
//제네릭 클래스 : 객체를 생성하는 시점에 실제 타입을 지정, 전역 변수처럼 사용
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
- 타입 매개변수 
< > 안에 있는 변수명으로 변수의 이름과 타입의 이름을 구분하기 위해 하나의 대문자로 작성한다. 
제네릭 클래스는 여러 개의 타입 매개변수를 가질 수 있다.
----------------------------------------------------------------------------------------------------------------------
- 다이아몬드 연산자 < >
자바 7버전부터 제네릭 클래스를 생성할 때 생성자에 자료형을 명시하지 않아도 된다. 
컴파일러가 문맥을 통해 타입 매개변수를 추론
ex)
 int num1 = normalClass.<Integer>getAndReturn(100);
 int num2 = normalClass.getAndReturn(200);	
----------------------------------------------------------------------------------------------------------------------
- 와일드카드
제한을 두지 않는 기호로 제네릭에서는 ? 기호로 와일드 카드 사용
<?> //타입 매개변수에 모든 타입 사용
<? extends T> //T 타입과 T타입을 상속받는 하위 클래스 타입만 사용
<? super T> // T 타입과 T타입을 상속받은 상위 클래스 타입만 사용

----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
- 제네릭 메서드
클래스 내부의 특정 메서드만 제네릭으로 선언할 수 있다. -> 제네릭 메서드 
호출되는 시점에서 실제 제네릭 타입을 지정
해당 메서드 안에서만 사용, 지역변수처럼 사용 

class NormalClass {
    public <T> getAndReturn( T t ){  //type
           return t;
           //System.out.println(t.length( ));
           // 제네릭 메서드는 호출되는 시점에 제네릭 타입이 결정된다. (정의할 때 어떤 타입이 입력될 지 알 수 없다)
           // 정의하는 시점에 length( ) 같은 String 메서드 사용 불가 
    }
    public <K,V> void getAndPrint(K k,V v) { //key & value
          System.out.println( k + ":" + v);
          System.out.println( k.equals("ABC")); 
          //하지만 최상위 클래스인 Object 클래스 메서드는 사용 가능
    }
}

public class Main{
  public static void main(String[ ] args){
           NormalClass normalClass = new NormalClass( );
           int num1 = normalClass.<Integer>getAndReturn(100);
           int num2 = normalClass.getAndReturn(200);	
           //입력 매개변수 200으로 제네릭 타입을 유추할 수 이 있기 때문에 제네릭 타입 지정 생략

           normalClass.<String, Integer>.getAndPrint("ABC",1);
           normlaClass.getAndPrint("POI",2);
   }
}

cf) Object 클래스 메서드 : https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------